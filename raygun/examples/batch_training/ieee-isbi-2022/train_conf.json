
src_A = '/n/groups/htem/ESRF_id16a/tomo_ML/ResolutionEnhancement/jlr54_tests/volumes/CBxs_lobV_overview_90nm_rec5iter_db9_l20p15_.n5'
src_B = '/n/groups/htem/ESRF_id16a/tomo_ML/ResolutionEnhancement/jlr54_tests/volumes/CBxs_lobV_bottomp100um_30nm_rec_db9_.n5'
common_voxel_size = (30, 30, 30) #voxel size to cast all data into
ndims = 3
A_name = 'volumes/raw'
mask_A_name = 'volumes/training_mask'
B_name = 'volumes/raw'
mask_B_name = 'volumes/volume_mask'
batch_size = 1
num_workers = 16
cache_size = 96
min_coefvar =  1e-02
adam_betas = [0.5, 0.999]

# sampling_bottleneck = True

g_init_learning_rate = 0.00004
gnet_type = 'resnet'
gnet_kwargs = {
    input_nc = 1
    output_nc = 1
    norm_layer = 'partial(torch.nn.InstanceNorm3d, track_running_stats=True, momentum=0.01)'
    # padding_type = 'valid'
    activation = 'torch.nn.SELU'#torch.nn.Tanh #torch.nn.SiLU#
    # add_noise = True
    ngf = 64
    # constant_upsample = True # unet specific
    # fmap_inc_factor = 2 # unet specific
    # residual = True # unet specific
    n_blocks = 9 # resnet specific
}

pretrain_gnet = False

d_init_learning_rate = 0.000004
dnet_type = 'classic'
dnet_kwargs = {
    input_nc = 1
    n_layers = 4
    ngf = 64
}

spawn_subprocess = True
side_length = 96 # requires odd number for valid resnet9 (which gives odd output)        
num_epochs = 300000
log_every = 20
